import type { VercelRequest, VercelResponse } from '@vercel/node';

interface CaptionSegment {
  text: string;
  start: number;
  duration: number;
}

// 格式化字幕文本
function formatCaptions(segments: CaptionSegment[], withTimestamp: boolean): string {
  if (!segments || segments.length === 0) {
    return "無可用字幕內容";
  }

  return segments.map(segment => {
    const text = segment.text.trim();
    
    if (withTimestamp) {
      const minutes = Math.floor(segment.start / 60);
      const seconds = Math.floor(segment.start % 60);
      const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      return `[${timestamp}] ${text}`;
    }
    return text;
  }).join('\n');
}

// 解析 SRT 格式字幕
function parseSRTAndFormat(srtContent: string, withTimestamp: boolean): string {
  if (!srtContent || srtContent.trim().length === 0) {
    return "無可用字幕內容";
  }

  // 分割 SRT 區塊
  const blocks = srtContent.trim().split(/\n\n+/);
  const lines: string[] = [];

  for (const block of blocks) {
    const blockLines = block.trim().split('\n');
    if (blockLines.length < 3) continue;

    // SRT 格式：
    // 1
    // 00:00:01,360 --> 00:00:03,040
    // 字幕文本
    const timeLine = blockLines[1];
    const textLines = blockLines.slice(2);
    
    if (withTimestamp) {
      // 提取開始時間 (HH:MM:SS,mmm)
      const timeMatch = timeLine.match(/^(\d{2}):(\d{2}):(\d{2})/);
      if (timeMatch) {
        const minutes = parseInt(timeMatch[2]);
        const seconds = parseInt(timeMatch[3]);
        const timestamp = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        lines.push(`[${timestamp}] ${textLines.join(' ')}`);
      } else {
        lines.push(textLines.join(' '));
      }
    } else {
      lines.push(textLines.join(' '));
    }
  }

  return lines.length > 0 ? lines.join('\n') : "無可用字幕內容";
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
  const { videoId, lang, format } = req.query;

  if (!videoId || typeof videoId !== 'string') {
    return res.status(400).json({ error: 'Video ID is required' });
  }

  // Use server environment variable only
  const apiKey = process.env.RAPIDAPI_KEY;

  if (!apiKey) {
    return res.status(500).json({ 
      error: 'API key not configured. Please set RAPIDAPI_KEY environment variable.' 
    });
  }

  // 如果請求所有字幕內容（一次性下載）
  if (format === 'all') {
    try {
      // 1. 獲取字幕列表（含類型標記）- 使用 YouTube V31 API
      const listUrl = `https://youtube-v31.p.rapidapi.com/captions?part=snippet&videoId=${videoId}`;
      const listOptions = {
        method: 'GET',
        headers: {
          'x-rapidapi-key': apiKey,
          'x-rapidapi-host': 'youtube-v31.p.rapidapi.com'
        }
      };

      let formattedTracks: any[] = [];
      
      // 嘗試從 YouTube V31 API 獲取字幕列表
      try {
        const listResponse = await fetch(listUrl, listOptions);
        if (listResponse.ok) {
          const listData = await listResponse.json();
          const captionItems = listData.items || [];
          
          // 格式化字幕軌列表
          formattedTracks = captionItems.map((item: any) => {
            const snippet = item.snippet || {};
            return {
              lang: snippet.name 
                ? `${getLanguageName(snippet.language)} (${snippet.name})` 
                : getLanguageName(snippet.language),
              code: snippet.language || '',
              url: '',
              isAutoGenerated: snippet.trackKind === 'asr' || snippet.isAutoSynced || false,
              isCC: snippet.isCC || false
            };
          });
        }
      } catch (listError) {
        console.warn('YouTube V31 API 字幕列表獲取失敗，將從下載的字幕生成列表:', listError);
      }

      // 2. 下載所有字幕內容 - 使用 download-all API
      const downloadUrl = `https://youtube-captions-transcript-subtitles-video-combiner.p.rapidapi.com/download-all/${videoId}?format_subtitle=srt&format_answer=json`;
      const downloadOptions = {
        method: 'GET',
        headers: {
          'x-rapidapi-key': apiKey,
          'x-rapidapi-host': 'youtube-captions-transcript-subtitles-video-combiner.p.rapidapi.com'
        }
      };

      const downloadResponse = await fetch(downloadUrl, downloadOptions);
      let allSubtitles: { [key: string]: { withTimestamp: string; withoutTimestamp: string } } = {};

      if (downloadResponse.ok) {
        const downloadData = await downloadResponse.json();
        
        // API 返回格式：[{ languageCode: "en", subtitle: "SRT格式字幕..." }, ...]
        if (Array.isArray(downloadData)) {
          downloadData.forEach((item: any) => {
            const langCode = item.languageCode;
            const srtContent = item.subtitle;
            
            if (langCode && srtContent) {
              // 預先格式化兩種版本（有時間碼 / 無時間碼）
              allSubtitles[langCode] = {
                withTimestamp: parseSRTAndFormat(srtContent, true),
                withoutTimestamp: parseSRTAndFormat(srtContent, false)
              };
            }
          });
        }
      }

      // 如果 YouTube V31 API 沒有返回字幕列表，從下載的字幕生成列表
      if (formattedTracks.length === 0 && Object.keys(allSubtitles).length > 0) {
        formattedTracks = Object.keys(allSubtitles).map(langCode => ({
          lang: getLanguageName(langCode),
          code: langCode,
          url: '',
          isAutoGenerated: false,  // 無法確定，預設為 false
          isCC: false  // 無法確定，預設為 false
        }));
      }

      // 返回字幕列表和所有字幕內容
      return res.status(200).json({
        captions: formattedTracks,
        allSubtitles: allSubtitles
      });

    } catch (error) {
      console.error('Fetch all captions error:', error);
      return res.status(500).json({ 
        error: 'An internal server error occurred', 
        details: (error as Error).message 
      });
    }
  }

  // 如果請求格式化字幕和指定語言，獲取該語言的字幕文本（向後兼容）
  if (format === 'text' && lang) {
    const url = `https://youtube-captions-transcript-subtitles-video-combiner.p.rapidapi.com/download-all/${videoId}?format_subtitle=srt&format_answer=json`;
    const options = {
      method: 'GET',
      headers: {
        'x-rapidapi-key': apiKey,
        'x-rapidapi-host': 'youtube-captions-transcript-subtitles-video-combiner.p.rapidapi.com'
      }
    };

    try {
      const response = await fetch(url, options);
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ message: 'Unknown error' }));
        return res.status(response.status).json({ 
          error: 'Failed to fetch captions from API', 
          details: errorData 
        });
      }

      const data = await response.json();
      const withTimestamp = req.query.timestamp === 'true';
      
      // API 返回格式：[{ languageCode: "en", subtitle: "SRT格式字幕..." }, ...]
      if (!Array.isArray(data)) {
        return res.status(200).send("無可用字幕內容");
      }

      // 查找匹配的語言（支援語言代碼變體）
      const targetLang = (lang as string).toLowerCase();
      const matchedCaption = data.find((item: any) => {
        const itemLang = item.languageCode?.toLowerCase() || '';
        return itemLang === targetLang || 
               itemLang.startsWith(targetLang + '-') ||
               targetLang.startsWith(itemLang + '-');
      });

      if (!matchedCaption || !matchedCaption.subtitle) {
        return res.status(200).send("找不到該語言的字幕");
      }

      const formattedText = parseSRTAndFormat(matchedCaption.subtitle, withTimestamp);
      return res.status(200).send(formattedText);
      
    } catch (error) {
      console.error('Caption fetch error:', error);
      return res.status(500).json({ error: 'An internal server error occurred', details: (error as Error).message });
    }
  }

  // 獲取可用的字幕軌列表（向後兼容）
  const url = `https://youtube-v31.p.rapidapi.com/captions?part=snippet&videoId=${videoId}`;
  const options = {
    method: 'GET',
    headers: {
      'x-rapidapi-key': apiKey,
      'x-rapidapi-host': 'youtube-v31.p.rapidapi.com'
    }
  };

  try {
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ message: 'Unknown error' }));
      return res.status(response.status).json({ 
        error: 'Failed to fetch caption list from YouTube V31 API', 
        details: errorData 
      });
    }

    const data = await response.json();
    
    // YouTube V31 API 回應格式
    const captionItems = data.items || [];
    const formattedTracks = captionItems.map((item: any) => {
      const snippet = item.snippet || {};
      return {
        lang: snippet.name 
          ? `${getLanguageName(snippet.language)} (${snippet.name})` 
          : getLanguageName(snippet.language),
        code: snippet.language || '',
        url: '',
        isAutoGenerated: snippet.trackKind === 'asr' || snippet.isAutoSynced || false,
        isCC: snippet.isCC || false
      };
    });

    res.status(200).json({ 
      captions: formattedTracks
    });

  } catch (error) {
    console.error('Caption list error:', error);
    res.status(500).json({ error: 'An internal server error occurred', details: (error as Error).message });
  }
}

// 語言代碼轉換為中文名稱
function getLanguageName(code: string): string {
  const languageMap: { [key: string]: string } = {
    'en': '英文',
    'zh-TW': '繁體中文',
    'zh-CN': '簡體中文',
    'zh-Hans': '簡體中文',
    'zh-Hant': '繁體中文',
    'ja': '日文',
    'ko': '韓文',
    'es': '西班牙文',
    'es-419': '西班牙文（拉美）',
    'es-ES': '西班牙文（西班牙）',
    'fr': '法文',
    'de': '德文',
    'de-DE': '德文',
    'it': '義大利文',
    'pt': '葡萄牙文',
    'pt-BR': '葡萄牙文（巴西）',
    'pt-PT': '葡萄牙文（葡萄牙）',
    'ru': '俄文',
    'ar': '阿拉伯文',
    'hi': '印度文',
    'th': '泰文',
    'vi': '越南文',
    'id': '印尼文',
    'ms': '馬來文',
    'fil': '菲律賓文',
    'nl': '荷蘭文',
    'pl': '波蘭文',
    'tr': '土耳其文',
    'sv': '瑞典文',
    'da': '丹麥文',
    'no': '挪威文',
    'fi': '芬蘭文',
    'cs': '捷克文',
    'el': '希臘文',
    'he': '希伯來文',
    'uk': '烏克蘭文',
    'ro': '羅馬尼亞文',
    'hu': '匈牙利文',
    'bg': '保加利亞文',
    'hr': '克羅埃西亞文',
    'sk': '斯洛伐克文',
  };
  
  // 優先匹配完整代碼
  if (languageMap[code]) {
    return languageMap[code];
  }
  
  // 如果沒有匹配，嘗試匹配基礎語言代碼（例如 en-US -> en）
  const baseCode = code.split('-')[0];
  if (languageMap[baseCode]) {
    return languageMap[baseCode];
  }
  
  return code.toUpperCase();
}
