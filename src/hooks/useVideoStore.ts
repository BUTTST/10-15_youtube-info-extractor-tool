import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

// --- Type Definitions ---
export interface VideoDetails {
  id: string;
  title: string;
  thumbnail: string;
  views: string;
  publishDate: string;
  author: string;
  url: string; 
}

export interface CaptionTrack {
  lang: string;
  code: string;
  url: string;
  isAutoGenerated: boolean;
  isCC?: boolean; // CC 字幕標記（可選，用於區分是否為 CC 字幕）
}

export interface HistoryItem {
  id: string;
  details: VideoDetails;
  captions?: CaptionTrack[];
  formattedCaptions?: { [lang: string]: string };
  queriedAt: string;
}

interface VideoState {
  // State
  urlInput: string;
  isLoading: boolean;
  error: string | null;
  currentVideo: HistoryItem | null;
  history: HistoryItem[];

  // Actions
  setUrlInput: (url: string) => void;
  fetchVideoInfo: (url: string) => Promise<void>;
  fetchFormattedCaption: (videoId: string, lang: string, withTimestamp: boolean) => Promise<string>;
  clearCurrentVideo: () => void;
  loadFromHistory: (item: HistoryItem) => Promise<void>;
  
  // History Actions
  addOrUpdateHistory: (item: HistoryItem) => void;
  removeFromHistory: (id: string) => void;
  clearHistory: () => void;
}

// --- Zustand Store ---
export const useVideoStore = create<VideoState>()(
  persist(
    (set, get) => ({
      // --- Initial State ---
      urlInput: '',
      isLoading: false,
      error: null,
      currentVideo: null,
      history: [],

      // --- Actions ---
      setUrlInput: (url) => set({ urlInput: url }),

      fetchVideoInfo: async (url) => {
        if (!url) return;
        set({ isLoading: true, error: null, currentVideo: null });

        try {
          // 獲取影片資訊
          const infoRes = await fetch(`/api/getVideoInfo?url=${encodeURIComponent(url)}`);
          
          if (!infoRes.ok) {
            const errorData = await infoRes.json().catch(() => ({ error: 'Network error' }));
            throw new Error(errorData.error || 'Failed to fetch video details');
          }
          
          const infoData = await infoRes.json();
          
          // 提取最高畫質的縮圖
          let thumbnail = '';
          if (infoData.thumbnails && Array.isArray(infoData.thumbnails) && infoData.thumbnails.length > 0) {
            // 獲取最後一個（最高解析度）的縮圖
            thumbnail = infoData.thumbnails[infoData.thumbnails.length - 1].url;
          }
          
          const details: VideoDetails = {
            id: infoData.id,
            title: infoData.title || 'Unknown Title',
            thumbnail: thumbnail,
            views: infoData.viewCount || '0',
            publishDate: infoData.publishedAt || new Date().toISOString(),
            author: infoData.author || 'Unknown Author',
            url: url
          };

          // 獲取字幕列表和所有字幕內容（一次性下載）
          let captionTracks: CaptionTrack[] = [];
          let allFormattedCaptions: { [key: string]: string } = {};
          
          try {
            const captionsRes = await fetch(`/api/getCaptions?videoId=${details.id}&format=all`);
            if (captionsRes.ok) {
              const captionsData = await captionsRes.json();
              
              // 處理字幕軌列表
              if (captionsData.captions && Array.isArray(captionsData.captions)) {
                captionTracks = captionsData.captions.map((track: any) => ({
                  lang: track.lang,
                  code: track.code,
                  url: track.url || '',
                  isAutoGenerated: track.isAutoGenerated || false,
                  isCC: track.isCC || false
                }));
              }
              
              // 處理所有字幕內容（預格式化的）
              if (captionsData.allSubtitles) {
                const allSubtitles = captionsData.allSubtitles;
                
                // 將預格式化的字幕存儲到緩存中
                // 格式：{ "en-true": "...", "en-false": "...", "ja-true": "...", ... }
                Object.keys(allSubtitles).forEach(langCode => {
                  const subtitle = allSubtitles[langCode];
                  if (subtitle) {
                    allFormattedCaptions[`${langCode}-true`] = subtitle.withTimestamp || '';
                    allFormattedCaptions[`${langCode}-false`] = subtitle.withoutTimestamp || '';
                  }
                });
              }
            }
          } catch (captionError) {
            console.warn('Failed to fetch captions:', captionError);
            // 繼續執行，只是沒有字幕
          }

          const newHistoryItem: HistoryItem = {
            id: details.id,
            details,
            captions: captionTracks,
            formattedCaptions: allFormattedCaptions,
            queriedAt: new Date().toISOString(),
          };

          set({ currentVideo: newHistoryItem, error: null });
          get().addOrUpdateHistory(newHistoryItem);

        } catch (err: any) {
          console.error('Fetch video info error:', err);
          set({ 
            error: err.message || '無法獲取影片資訊，請檢查網址或稍後再試',
            currentVideo: null
          });
        } finally {
          set({ isLoading: false });
        }
      },

      fetchFormattedCaption: async (videoId, lang, withTimestamp) => {
        // 直接從緩存讀取，不再調用 API
        const state = get();
        const currentVideo = state.currentVideo;
        
        if (!currentVideo || currentVideo.id !== videoId) {
          return '❌ 影片資訊不可用';
        }
        
        const cacheKey = `${lang}-${withTimestamp}`;
        const cachedCaption = currentVideo.formattedCaptions?.[cacheKey];
        
        if (cachedCaption) {
          return cachedCaption;
        }
        
        // 如果緩存中沒有，可能是語言代碼不匹配，嘗試查找相似的語言
        const formattedCaptions = currentVideo.formattedCaptions || {};
        const allKeys = Object.keys(formattedCaptions);
        
        // 查找匹配的語言（支援語言代碼變體，如 en 和 en-US）
        const matchedKey = allKeys.find(key => {
          const keyLang = key.split('-')[0];
          const keyTimestamp = key.endsWith('true');
          return (keyLang === lang || keyLang.startsWith(lang + '-') || lang.startsWith(keyLang + '-')) 
                 && keyTimestamp === withTimestamp;
        });
        
        if (matchedKey) {
          return formattedCaptions[matchedKey];
        }
        
        return '❌ 該語言的字幕尚未下載或不可用';
      },
      clearCurrentVideo: () => set({ currentVideo: null }),
      
      loadFromHistory: async (item: HistoryItem) => {
        set({ isLoading: true, error: null });
        
        try {
          // 直接使用緩存的數據，不重新獲取（因為字幕已經完整下載）
          set({ currentVideo: item, urlInput: item.details.url });
          
          // 如果需要，可以在背景更新影片資訊（觀看次數等）
          fetch(`/api/getVideoInfo?url=${encodeURIComponent(item.details.url)}`)
            .then(res => res.ok ? res.json() : null)
            .then(infoData => {
              if (infoData) {
                const updatedItem: HistoryItem = {
                  ...item,
                  details: {
                    id: infoData.id || item.details.id,
                    title: infoData.title || item.details.title,
                    thumbnail: infoData.thumbnail?.[0]?.url || item.details.thumbnail,
                    views: infoData.viewCount || item.details.views,
                    publishDate: infoData.publishedAt || item.details.publishDate,
                    author: infoData.author || item.details.author,
                    url: item.details.url
                  },
                  // 保留已緩存的字幕數據
                  captions: item.captions,
                  formattedCaptions: item.formattedCaptions,
                  queriedAt: item.queriedAt
                };
                
                set(state => {
                  if (state.currentVideo?.id === updatedItem.id) {
                    return {
                      currentVideo: updatedItem,
                      history: state.history.map(h => h.id === updatedItem.id ? updatedItem : h)
                    };
                  }
                  return {
                    history: state.history.map(h => h.id === updatedItem.id ? updatedItem : h)
                  };
                });
              }
            })
            .catch(err => console.warn('Background update failed:', err));
        } catch (err: any) {
          set({ currentVideo: item, urlInput: item.details.url, error: err.message });
        } finally {
          set({ isLoading: false });
        }
      },
      
      // History Actions
      addOrUpdateHistory: (item) => set(state => ({
        history: state.history.some(h => h.id === item.id)
          ? state.history.map(h => h.id === item.id ? item : h)
          : [...state.history, item]
      })),
      removeFromHistory: (id) => set(state => ({
        history: state.history.filter(h => h.id !== id)
      })),
      clearHistory: () => set({ history: [] }),
    }),
    {
      name: 'yt-video-history', // local storage key
      storage: createJSONStorage(() => localStorage),
    }
  )
);