import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

// --- Type Definitions ---
export interface VideoDetails {
  id: string;
  title: string;
  thumbnail: string;
  views: string;
  publishDate: string;
  author: string;
  url: string; 
}

export interface CaptionTrack {
  lang: string;
  code: string;
  url: string;
  isAutoGenerated: boolean;
  isCC?: boolean; // CC 字幕標記（可選，用於區分是否為 CC 字幕）
}

export interface HistoryItem {
  id: string;
  details: VideoDetails;
  captions?: CaptionTrack[];
  formattedCaptions?: { [lang: string]: string };
  queriedAt: string;
}

interface VideoState {
  // State
  urlInput: string;
  isLoading: boolean;
  error: string | null;
  currentVideo: HistoryItem | null;
  history: HistoryItem[];
  // playlist / download UI state
  playlistItems: Array<any> | null;
  downloadCandidatesCache: { [videoId: string]: any } | null;
  isDownloadPanelOpen: boolean;

  // Actions
  setUrlInput: (url: string) => void;
  fetchVideoInfo: (url: string) => Promise<void>;
  fetchFormattedCaption: (videoId: string, lang: string, withTimestamp: boolean) => Promise<string>;
  // Playlist & download (degraded: return direct URLs)
  fetchPlaylistInfo: (url: string) => Promise<void>;
  fetchDownloadCandidates: (url: string, format: 'mp4' | 'mp3') => Promise<any>;
  openDownloadPanel: () => void;
  closeDownloadPanel: () => void;
  clearCurrentVideo: () => void;
  loadFromHistory: (item: HistoryItem) => Promise<void>;
  
  // History Actions
  addOrUpdateHistory: (item: HistoryItem) => void;
  removeFromHistory: (id: string) => void;
  clearHistory: () => void;
}

// --- Zustand Store ---
export const useVideoStore = create<VideoState>()(
  persist(
    (set, get) => ({
      // --- Initial State ---
      urlInput: '',
      isLoading: false,
      error: null,
      currentVideo: null,
      history: [],
      // download/playlist UI state (degraded: provide direct URLs only)
      playlistItems: null,
      downloadCandidatesCache: null,
      isDownloadPanelOpen: false,

      // --- Actions ---
      setUrlInput: (url) => set({ urlInput: url }),

      fetchVideoInfo: async (url) => {
        if (!url) return;

        const extractVideoIdFromUrl = (input: string): string | null => {
          const patterns = [
            /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^#\&\?\s]{11})/,
            /^([^#\&\?\s]{11})$/,
          ];

          for (const pattern of patterns) {
            const match = input.match(pattern);
            if (match && match[1]) {
              return match[1];
            }
          }

          return null;
        };

        const fallbackVideoId = extractVideoIdFromUrl(url);

        set({ isLoading: true, error: null, currentVideo: null });

        try {
          // 獲取影片資訊
          const infoRes = await fetch(`/api/getVideoInfo?url=${encodeURIComponent(url)}`);
          
          if (!infoRes.ok) {
            const errorData = await infoRes.json().catch(() => ({ error: 'Network error' }));
            throw new Error(errorData.error || 'Failed to fetch video details');
          }
          
          const infoData = await infoRes.json();
          
          // 提取最高畫質的縮圖
          let thumbnail = '';
          if (infoData.thumbnails && Array.isArray(infoData.thumbnails) && infoData.thumbnails.length > 0) {
            // 獲取最後一個（最高解析度）的縮圖
            thumbnail = infoData.thumbnails[infoData.thumbnails.length - 1].url;
          }
          
          const resolvedVideoId = infoData.id || fallbackVideoId || '';

          const details: VideoDetails = {
            id: resolvedVideoId,
            title: infoData.title || 'Unknown Title',
            thumbnail: thumbnail || (resolvedVideoId ? `https://img.youtube.com/vi/${resolvedVideoId}/hqdefault.jpg` : ''),
            views: infoData.viewCount || '0',
            publishDate: infoData.publishedAt || new Date().toISOString(),
            author: infoData.author || 'Unknown Author',
            url: url
          };

          // 獲取字幕列表和所有字幕內容（一次性下載）
          let captionTracks: CaptionTrack[] = [];
          let allFormattedCaptions: { [key: string]: string } = {};
          
          try {
            if (resolvedVideoId) {
              const captionsRes = await fetch(`/api/getCaptions?videoId=${resolvedVideoId}&format=all`);
              if (captionsRes.ok) {
                const captionsData = await captionsRes.json();
                
                // 處理字幕軌列表
                if (captionsData.captions && Array.isArray(captionsData.captions)) {
                  captionTracks = captionsData.captions.map((track: any) => ({
                    lang: track.lang,
                    code: track.code,
                    url: track.url || '',
                    isAutoGenerated: track.isAutoGenerated || false,
                    isCC: track.isCC || false
                  }));
                }
                
                // 處理所有字幕內容（預格式化的）
                if (captionsData.allSubtitles) {
                  const allSubtitles = captionsData.allSubtitles;
                  
                  // 將預格式化的字幕存儲到緩存中
                  // 格式：{ "en-true": "...", "en-false": "...", "ja-true": "...", ... }
                  Object.keys(allSubtitles).forEach(langCode => {
                    const subtitle = allSubtitles[langCode];
                    if (subtitle) {
                      allFormattedCaptions[`${langCode}-true`] = subtitle.withTimestamp || '';
                      allFormattedCaptions[`${langCode}-false`] = subtitle.withoutTimestamp || '';
                    }
                  });
                }
              }
            }
          } catch (captionError) {
            console.warn('Failed to fetch captions:', captionError);
            // 繼續執行，只是沒有字幕
          }

          const newHistoryItem: HistoryItem = {
            id: details.id,
            details,
            captions: captionTracks,
            formattedCaptions: allFormattedCaptions,
            queriedAt: new Date().toISOString(),
          };

          set({ currentVideo: newHistoryItem, error: null });
          get().addOrUpdateHistory(newHistoryItem);

        } catch (err: any) {
          console.error('Fetch video info error:', err);
          set({ 
            error: err.message || '無法獲取影片資訊，請檢查網址或稍後再試',
            currentVideo: null
          });
        } finally {
          set({ isLoading: false });
        }
      },

      // Fetch playlist info (uses server API)
      fetchPlaylistInfo: async (url) => {
        if (!url) return;
        set({ isLoading: true, error: null, playlistItems: null });
        try {
          const res = await fetch(`/api/getPlaylistInfo?url=${encodeURIComponent(url)}`);
          if (!res.ok) {
            const d = await res.json().catch(() => ({}));
            throw new Error(d.error || 'Failed to fetch playlist');
          }
          const data = await res.json();
          set({ playlistItems: data.items || [], isLoading: false });
        } catch (err: any) {
          console.warn('fetchPlaylistInfo error', err);
          set({ error: err.message || '無法取得播放清單', isLoading: false });
        }
      },

      // Fetch direct download candidate URLs for a video (degraded: no server-side transcode)
      fetchDownloadCandidates: async (url, format) => {
        if (!url) return null;
        set({ isLoading: true, error: null });
        try {
          const res = await fetch(`/api/getDownloadUrls?url=${encodeURIComponent(url)}&format=${encodeURIComponent(format)}`);
          if (!res.ok) {
            const d = await res.json().catch(() => ({}));
            throw new Error(d.error || 'Failed to fetch download URLs');
          }
          const data = await res.json();
          const cache = get().downloadCandidatesCache || {};
          cache[data.id] = data;
          set({ downloadCandidatesCache: cache, isLoading: false });
          return data;
        } catch (err: any) {
          console.warn('fetchDownloadCandidates error', err);
          set({ error: err.message || '無法取得下載候選', isLoading: false });
          return null;
        }
      },

      // UI controls for download panel
      openDownloadPanel: () => set({ isDownloadPanelOpen: true }),
      closeDownloadPanel: () => set({ isDownloadPanelOpen: false }),

      fetchFormattedCaption: async (videoId, lang, withTimestamp) => {
        // 直接從緩存讀取，不再調用 API
        const state = get();
        const currentVideo = state.currentVideo;
        
        if (!currentVideo || currentVideo.id !== videoId) {
          return '❌ 影片資訊不可用';
        }
        
        const cacheKey = `${lang}-${withTimestamp}`;
        const cachedCaption = currentVideo.formattedCaptions?.[cacheKey];
        
        if (cachedCaption) {
          return cachedCaption;
        }
        
        // 如果緩存中沒有，可能是語言代碼不匹配，嘗試查找相似的語言
        const formattedCaptions = currentVideo.formattedCaptions || {};
        const allKeys = Object.keys(formattedCaptions);
        
        // 查找匹配的語言（支援語言代碼變體，如 en 和 en-US）
        const matchedKey = allKeys.find(key => {
          const keyLang = key.split('-')[0];
          const keyTimestamp = key.endsWith('true');
          return (keyLang === lang || keyLang.startsWith(lang + '-') || lang.startsWith(keyLang + '-')) 
                 && keyTimestamp === withTimestamp;
        });
        
        if (matchedKey) {
          return formattedCaptions[matchedKey];
        }
        
        return '❌ 該語言的字幕尚未下載或不可用';
      },
      clearCurrentVideo: () => set({ currentVideo: null }),
      
      loadFromHistory: async (item: HistoryItem) => {
        set({ isLoading: true, error: null });
        
        try {
          // 直接使用緩存的數據，不重新獲取（因為字幕已經完整下載）
          set({ currentVideo: item, urlInput: item.details.url });
          
          // 如果需要，可以在背景更新影片資訊（觀看次數等）
          fetch(`/api/getVideoInfo?url=${encodeURIComponent(item.details.url)}`)
            .then(res => res.ok ? res.json() : null)
            .then(infoData => {
              if (infoData) {
                const updatedItem: HistoryItem = {
                  ...item,
                  details: {
                    id: infoData.id || item.details.id,
                    title: infoData.title || item.details.title,
                    thumbnail: infoData.thumbnail?.[0]?.url || item.details.thumbnail,
                    views: infoData.viewCount || item.details.views,
                    publishDate: infoData.publishedAt || item.details.publishDate,
                    author: infoData.author || item.details.author,
                    url: item.details.url
                  },
                  // 保留已緩存的字幕數據
                  captions: item.captions,
                  formattedCaptions: item.formattedCaptions,
                  queriedAt: item.queriedAt
                };
                
                set(state => {
                  if (state.currentVideo?.id === updatedItem.id) {
                    return {
                      currentVideo: updatedItem,
                      history: state.history.map(h => h.id === updatedItem.id ? updatedItem : h)
                    };
                  }
                  return {
                    history: state.history.map(h => h.id === updatedItem.id ? updatedItem : h)
                  };
                });
              }
            })
            .catch(err => console.warn('Background update failed:', err));
        } catch (err: any) {
          set({ currentVideo: item, urlInput: item.details.url, error: err.message });
        } finally {
          set({ isLoading: false });
        }
      },
      
      // History Actions
      addOrUpdateHistory: (item) => set(state => ({
        history: state.history.some(h => h.id === item.id)
          ? state.history.map(h => h.id === item.id ? item : h)
          : [...state.history, item]
      })),
      removeFromHistory: (id) => set(state => ({
        history: state.history.filter(h => h.id !== id)
      })),
      clearHistory: () => set({ history: [] }),
    }),
    {
      name: 'yt-video-history', // local storage key
      storage: createJSONStorage(() => localStorage),
    }
  )
);