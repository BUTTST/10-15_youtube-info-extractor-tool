import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

// --- Type Definitions ---
export interface VideoDetails {
  id: string;
  title: string;
  thumbnail: string;
  views: string;
  publishDate: string;
  author: string;
  url: string; 
}

export interface CaptionTrack {
  lang: string;
  code: string;
  url: string;
  isAutoGenerated: boolean;
}

export interface HistoryItem {
  id: string;
  details: VideoDetails;
  captions?: CaptionTrack[];
  formattedCaptions?: { [lang: string]: string };
  queriedAt: string;
}

interface VideoState {
  // State
  urlInput: string;
  isLoading: boolean;
  error: string | null;
  currentVideo: HistoryItem | null;
  history: HistoryItem[];

  // Actions
  setUrlInput: (url: string) => void;
  fetchVideoInfo: (url: string) => Promise<void>;
  fetchFormattedCaption: (videoId: string, lang: string, withTimestamp: boolean) => Promise<string>;
  clearCurrentVideo: () => void;
  loadFromHistory: (item: HistoryItem) => Promise<void>;
  
  // History Actions
  addOrUpdateHistory: (item: HistoryItem) => void;
  removeFromHistory: (id: string) => void;
  clearHistory: () => void;
}

// --- Zustand Store ---
export const useVideoStore = create<VideoState>()(
  persist(
    (set, get) => ({
      // --- Initial State ---
      urlInput: '',
      isLoading: false,
      error: null,
      currentVideo: null,
      history: [],

      // --- Actions ---
      setUrlInput: (url) => set({ urlInput: url }),

      fetchVideoInfo: async (url) => {
        if (!url) return;
        set({ isLoading: true, error: null, currentVideo: null });

        try {
          // 獲取影片資訊
          const infoRes = await fetch(`/api/getVideoInfo?url=${encodeURIComponent(url)}`);
          
          if (!infoRes.ok) {
            const errorData = await infoRes.json().catch(() => ({ error: 'Network error' }));
            throw new Error(errorData.error || 'Failed to fetch video details');
          }
          
          const infoData = await infoRes.json();
          
          // 提取最高畫質的縮圖
          let thumbnail = '';
          if (infoData.thumbnails && Array.isArray(infoData.thumbnails) && infoData.thumbnails.length > 0) {
            // 獲取最後一個（最高解析度）的縮圖
            thumbnail = infoData.thumbnails[infoData.thumbnails.length - 1].url;
          }
          
          const details: VideoDetails = {
            id: infoData.id,
            title: infoData.title || 'Unknown Title',
            thumbnail: thumbnail,
            views: infoData.viewCount || '0',
            publishDate: infoData.publishedAt || new Date().toISOString(),
            author: infoData.author || 'Unknown Author',
            url: url
          };

          // 獲取字幕列表
          let captionTracks: CaptionTrack[] = [];
          try {
            const captionsRes = await fetch(`/api/getCaptions?videoId=${details.id}`);
            if (captionsRes.ok) {
              const captionsData = await captionsRes.json();
              
              if (captionsData.captions && Array.isArray(captionsData.captions)) {
                captionTracks = captionsData.captions.map((track: any) => ({
                  lang: track.lang,
                  code: track.code,
                  url: track.url,
                  isAutoGenerated: track.isAutoGenerated || false
                }));
              }
            }
          } catch (captionError) {
            console.warn('Failed to fetch captions:', captionError);
            // 繼續執行，只是沒有字幕
          }

          const newHistoryItem: HistoryItem = {
            id: details.id,
            details,
            captions: captionTracks,
            queriedAt: new Date().toISOString(),
          };

          set({ currentVideo: newHistoryItem, error: null });
          get().addOrUpdateHistory(newHistoryItem);

        } catch (err: any) {
          console.error('Fetch video info error:', err);
          set({ 
            error: err.message || '無法獲取影片資訊，請檢查網址或稍後再試',
            currentVideo: null
          });
        } finally {
          set({ isLoading: false });
        }
      },

      fetchFormattedCaption: async (videoId, lang, withTimestamp) => {
        set({ isLoading: true });

        try {
            const res = await fetch(`/api/getCaptions?videoId=${videoId}&lang=${lang}&format=text&timestamp=${withTimestamp}`);
            if (!res.ok) {
              // 如果该语言的字幕不可用，尝试获取第一个可用的字幕
              const captionsRes = await fetch(`/api/getCaptions?videoId=${videoId}`);
              if (captionsRes.ok) {
                const captionsData = await captionsRes.json();
                if (captionsData.captions && captionsData.captions.length > 0) {
                  // 使用第一个可用的字幕作为替代
                  const firstCaption = captionsData.captions[0];
                  const fallbackRes = await fetch(`/api/getCaptions?videoId=${videoId}&lang=${firstCaption.code}&format=text&timestamp=${withTimestamp}`);
                  if (fallbackRes.ok) {
                    const text = await fallbackRes.text();
                    const warningText = `⚠️ 所選語言字幕不可用，已自動切換到：${firstCaption.lang}\n\n${text}`;
                    
                    // 保存到 formattedCaptions 缓存
                    set(state => ({
                      currentVideo: state.currentVideo ? {
                        ...state.currentVideo,
                        formattedCaptions: {
                          ...state.currentVideo.formattedCaptions,
                          [`${lang}-${withTimestamp}`]: warningText
                        }
                      } : null
                    }));
                    
                    return warningText;
                  }
                }
              }
              throw new Error('Failed to fetch caption');
            }
            const text = await res.text();
            
            // 保存到 formattedCaptions 缓存
            set(state => ({
              currentVideo: state.currentVideo ? {
                ...state.currentVideo,
                formattedCaptions: {
                  ...state.currentVideo.formattedCaptions,
                  [`${lang}-${withTimestamp}`]: text
                }
              } : null
            }));
            
            return text;
        } catch (err: any) {
          set({ error: err.message || 'An unknown error occurred' });
          return '❌ 無法載入字幕';
        } finally {
          set({ isLoading: false });
        }
      },
      clearCurrentVideo: () => set({ currentVideo: null }),
      
      loadFromHistory: async (item: HistoryItem) => {
        set({ isLoading: true, error: null });
        
        try {
          // 重新获取影片详情（免费API，获取最新数据）
          const res = await fetch(`/api/getVideoInfo?url=${encodeURIComponent(item.details.url)}`);
          
          if (res.ok) {
            const infoData = await res.json();
            
            // 更新影片详情，但保留字幕缓存
            const updatedItem: HistoryItem = {
              ...item,
              details: {
                id: infoData.id || item.details.id,
                title: infoData.title || item.details.title,
                thumbnail: infoData.thumbnail?.[0]?.url || item.details.thumbnail,
                views: infoData.viewCount || item.details.views,
                publishDate: infoData.publishedAt || item.details.publishDate,
                author: infoData.author || item.details.author,
                url: item.details.url
              },
              // 保留已缓存的字幕数据
              captions: item.captions,
              formattedCaptions: item.formattedCaptions,
              queriedAt: new Date().toISOString()
            };
            
            set({ currentVideo: updatedItem, urlInput: item.details.url });
            
            // 更新历史记录
            set(state => ({
              history: state.history.map(h => h.id === updatedItem.id ? updatedItem : h)
            }));
          } else {
            // 如果获取失败，直接使用缓存的数据
            set({ currentVideo: item, urlInput: item.details.url });
          }
        } catch (err: any) {
          // 出错时使用缓存的数据
          set({ currentVideo: item, urlInput: item.details.url, error: err.message });
        } finally {
          set({ isLoading: false });
        }
      },
      
      // History Actions
      addOrUpdateHistory: (item) => set(state => ({
        history: state.history.some(h => h.id === item.id)
          ? state.history.map(h => h.id === item.id ? item : h)
          : [...state.history, item]
      })),
      removeFromHistory: (id) => set(state => ({
        history: state.history.filter(h => h.id !== id)
      })),
      clearHistory: () => set({ history: [] }),
    }),
    {
      name: 'yt-video-history', // local storage key
      storage: createJSONStorage(() => localStorage),
    }
  )
);